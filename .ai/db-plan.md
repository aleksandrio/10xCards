# 10xCards Database Schema Plan

This document outlines the PostgreSQL database schema for the 10xCards application, based on the Product Requirements Document (PRD), tech stack, and planning session notes.

## 1. Types

This section defines custom data types (enums) used throughout the schema.

```sql
CREATE TYPE flashcard_creation_type AS ENUM ('manual', 'generated');
```

## 2. Tables

### `profiles`

Stores public user data and establishes a link to Supabase's `auth.users` table.

| Column Name | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `uuid` | `PRIMARY KEY`, `REFERENCES auth.users(id) ON DELETE CASCADE` | Foreign key to `auth.users` table. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of profile creation. |
| `updated_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of last profile update. |

### `decks`

Stores user-created flashcard decks.

| Column Name | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `uuid` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the deck. |
| `user_id` | `uuid` | `NOT NULL`, `REFERENCES auth.users(id) ON DELETE CASCADE` | The user who owns the deck. |
| `name` | `varchar(100)` | `NOT NULL` | Name of the deck. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of deck creation. |
| `updated_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of last deck update. |

### `generations`

Stores metrics for each AI flashcard generation event.

| Column Name | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `uuid` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the generation event. |
| `user_id` | `uuid` | `NOT NULL`, `REFERENCES auth.users(id) ON DELETE CASCADE` | The user who initiated the generation. |
| `deck_id` | `uuid` | `NOT NULL`, `REFERENCES decks(id) ON DELETE CASCADE` | The deck the flashcards were generated for. |
| `duration_ms` | `integer` | `NOT NULL` | Time taken for the generation in milliseconds. |
| `generated_cards_count` | `integer` | `NOT NULL` | Number of flashcards initially generated by the AI. |
| `accepted_cards_count` | `integer` | | Number of flashcards accepted by the user. Updated after review. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of generation event. |
| `updated_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of last generation update. |

### `generation_errors`

Logs errors that occur during the AI flashcard generation process.

| Column Name | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `uuid` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the error log. |
| `user_id` | `uuid` | `NOT NULL`, `REFERENCES auth.users(id) ON DELETE CASCADE` | The user who experienced the error. |
| `deck_id` | `uuid` | `REFERENCES decks(id) ON DELETE SET NULL` | The deck associated with the error, if any. |
| `error_message` | `text` | `NOT NULL` | The error message or description. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp when the error occurred. |

### `flashcards`

Stores individual flashcards with front and back content.

| Column Name | Data Type | Constraints | Description |
|---|---|---|---|
| `id` | `uuid` | `PRIMARY KEY`, `DEFAULT gen_random_uuid()` | Unique identifier for the flashcard. |
| `deck_id` | `uuid` | `NOT NULL`, `REFERENCES decks(id) ON DELETE CASCADE` | The deck this flashcard belongs to. |
| `generation_id` | `uuid` | `REFERENCES generations(id) ON DELETE SET NULL` | The generation event that created this card, if applicable. |
| `creation_type` | `flashcard_creation_type` | `NOT NULL` | How the flashcard was created ('manual' or 'generated'). |
| `front` | `varchar(200)` | `NOT NULL` | The "front" side of the flashcard. |
| `back` | `varchar(500)` | `NOT NULL` | The "back" side of the flashcard. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of flashcard creation. |
| `updated_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Timestamp of last flashcard update. |

## 3. Relationships

-   **`auth.users` to `profiles`**: One-to-One. Each user in `auth.users` can have one corresponding entry in `profiles`. The relationship is enforced by making `profiles.id` both a Primary Key and a Foreign Key referencing `auth.users.id`.
-   **`auth.users` to `decks`**: One-to-Many. A user can own many decks, but each deck belongs to only one user.
-   **`auth.users` to `generations`**: One-to-Many. A user can initiate many generation events.
-   **`auth.users` to `generation_errors`**: One-to-Many. A user can encounter multiple generation errors.
-   **`decks` to `flashcards`**: One-to-Many. A deck can contain many flashcards, but each flashcard belongs to only one deck.
-   **`decks` to `generations`**: One-to-Many. A deck can be the target of many generation events.
-   **`generations` to `flashcards`**: One-to-Many. A generation event can create many flashcards.

## 4. Indexes

To optimize query performance for fetching data related to specific users or decks, the following indexes should be created on foreign key columns:

```sql
CREATE INDEX idx_decks_user_id ON decks(user_id);
CREATE INDEX idx_generations_user_id ON generations(user_id);
CREATE INDEX idx_generations_deck_id ON generations(deck_id);
CREATE INDEX idx_generation_errors_user_id ON generation_errors(user_id);
CREATE INDEX idx_flashcards_deck_id ON flashcards(deck_id);
CREATE INDEX idx_flashcards_generation_id ON flashcards(generation_id);
```

## 5. PostgreSQL Policies (RLS)

Row-Level Security (RLS) must be enabled on all user-specific tables to ensure data privacy and that users can only access their own data.

```sql
-- Enable RLS
ALTER TABLE decks ENABLE ROW LEVEL SECURITY;
ALTER TABLE generations ENABLE ROW LEVEL SECURITY;
ALTER TABLE generation_errors ENABLE ROW LEVEL SECURITY;
ALTER TABLE flashcards ENABLE ROW LEVEL SECURITY;
```

### Policies for `decks` table

-   **SELECT, INSERT, UPDATE, DELETE**: Users can only manage their own decks.
    ```sql
    CREATE POLICY "Users can manage their own decks"
    ON decks FOR ALL
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);
    ```

### Policies for `generations` table

-   **SELECT, INSERT, UPDATE, DELETE**: Users can only manage their own generation events.
    ```sql
    CREATE POLICY "Users can manage their own generation events"
    ON generations FOR ALL
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);
    ```

### Policies for `generation_errors` table

-   **SELECT, INSERT**: Users can only view and create their own generation errors. (Update and Delete are not typically required for log tables).
    ```sql
    CREATE POLICY "Users can view their own generation errors"
    ON generation_errors FOR SELECT
    USING (auth.uid() = user_id);

    CREATE POLICY "Users can log their own generation errors"
    ON generation_errors FOR INSERT
    WITH CHECK (auth.uid() = user_id);
    ```

### Policies for `flashcards` table

-   **SELECT, INSERT, UPDATE, DELETE**: Users can only manage flashcards in decks they own.
    ```sql
    CREATE POLICY "Users can manage flashcards in their own decks"
    ON flashcards FOR ALL
    USING (
      EXISTS (
        SELECT 1 FROM decks
        WHERE decks.id = flashcards.deck_id AND decks.user_id = auth.uid()
      )
    )
    WITH CHECK (
      EXISTS (
        SELECT 1 FROM decks
        WHERE decks.id = flashcards.deck_id AND decks.user_id = auth.uid()
      )
    );
    ```

## 6. Additional Notes

-   **`updated_at` Automation**: To automatically update the `updated_at` timestamp on row updates, a trigger function should be created and applied to the `profiles`, `decks`, `generations`, and `flashcards` tables. This is a standard PostgreSQL practice to maintain data freshness.
    ```sql
    -- Function to update the updated_at column
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
       NEW.updated_at = NOW();
       RETURN NEW;
    END;
    $$ language 'plpgsql';

    -- Trigger for profiles
    CREATE TRIGGER set_updated_at_profiles
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

    -- Trigger for decks
    CREATE TRIGGER set_updated_at_decks
    BEFORE UPDATE ON decks
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

    -- Trigger for generations
    CREATE TRIGGER set_updated_at_generations
    BEFORE UPDATE ON generations
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

    -- Trigger for flashcards
    CREATE TRIGGER set_updated_at_flashcards
    BEFORE UPDATE ON flashcards
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();
    ```
-   **Application-Level Rules**: As specified in the session notes, the following business rules will be enforced by the application logic, not by database constraints, to keep the schema simple for the MVP:
    -   Maximum of 10 decks per user.
    -   Maximum of 100 flashcards per deck.
